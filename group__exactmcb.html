<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mcb LEDA Extension Package: Exact MCB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mcb LEDA Extension Package
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Exact MCB</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Undirected Minimum Cycle Basis</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp82f1eabf9b14d4671843db140105d78f"></a>The functions below are the more general implementation for undirected graphs. They also support multigraphs. As an underlying implementation they use the Support Vector approach (<a class="el" href="group__exactmcb.html#gaf0d7063e6370d4faed9fe384c04260b4" title="Compute a MCB of an undirected graph using the Support Vector Approach (de Pina&#39;s PhD thesis) algorit...">mcb::UMCB_SVA</a>). They should be the first choice of use unless some special requirements exist. </p>
</td></tr>
<tr class="memitem:gaf0d7063e6370d4faed9fe384c04260b4"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:gaf0d7063e6370d4faed9fe384c04260b4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#gaf0d7063e6370d4faed9fe384c04260b4">mcb::UMCB_SVA</a> (const graph &amp;g, array&lt; Container &gt; &amp;mcb, array&lt; Container &gt; &amp;proof, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:gaf0d7063e6370d4faed9fe384c04260b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a MCB of an undirected graph using the Support Vector Approach (de Pina's PhD thesis) algorithm.  <a href="group__exactmcb.html#gaf0d7063e6370d4faed9fe384c04260b4">More...</a><br /></td></tr>
<tr class="separator:gaf0d7063e6370d4faed9fe384c04260b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1b28748379d953fea05043cfc74beb"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:ga1e1b28748379d953fea05043cfc74beb"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga1e1b28748379d953fea05043cfc74beb">mcb::UMCB_SVA</a> (const graph &amp;g, array&lt; Container &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga1e1b28748379d953fea05043cfc74beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a MCB of an undirected weighted graph using the Support Vector Approach (de Pina's PhD thesis) algorithm.  <a href="group__exactmcb.html#ga1e1b28748379d953fea05043cfc74beb">More...</a><br /></td></tr>
<tr class="separator:ga1e1b28748379d953fea05043cfc74beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624d6f56bd60699e61d74deaa459e4da"><td class="memTemplParams" colspan="2">template&lt;class W , class Container &gt; </td></tr>
<tr class="memitem:ga624d6f56bd60699e61d74deaa459e4da"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga624d6f56bd60699e61d74deaa459e4da">mcb::UMCB_SVA</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; Container &gt; &amp;mcb, array&lt; Container &gt; &amp;proof, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga624d6f56bd60699e61d74deaa459e4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a MCB of an undirected weighted graph using the Support Vector Approach (de Pina's PhD thesis) algorithm.  <a href="group__exactmcb.html#ga624d6f56bd60699e61d74deaa459e4da">More...</a><br /></td></tr>
<tr class="separator:ga624d6f56bd60699e61d74deaa459e4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366093168b1b16f19b79fb6741d0c9f5"><td class="memTemplParams" colspan="2">template&lt;class W , class Container &gt; </td></tr>
<tr class="memitem:ga366093168b1b16f19b79fb6741d0c9f5"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga366093168b1b16f19b79fb6741d0c9f5">mcb::UMCB_SVA</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; Container &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga366093168b1b16f19b79fb6741d0c9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a MCB of an undirected weighted graph using the Support Vector Approach (de Pina's PhD thesis) algorithm.  <a href="group__exactmcb.html#ga366093168b1b16f19b79fb6741d0c9f5">More...</a><br /></td></tr>
<tr class="separator:ga366093168b1b16f19b79fb6741d0c9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c6c771dd268b9943b310fa48d72792"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga23c6c771dd268b9943b310fa48d72792">mcb::UMCB_HYBRID</a> (const leda::graph &amp;g, leda::array&lt; leda::d_int_set &gt; &amp;mcb, leda::array&lt; leda::d_int_set &gt; &amp;proof, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga23c6c771dd268b9943b310fa48d72792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a minimum cycle basis of an undirected graph using a hybrid algorithm.  <a href="group__exactmcb.html#ga23c6c771dd268b9943b310fa48d72792">More...</a><br /></td></tr>
<tr class="separator:ga23c6c771dd268b9943b310fa48d72792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6f1484504fe60879165d0d8eab1cbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga1f6f1484504fe60879165d0d8eab1cbe">mcb::UMCB_HYBRID</a> (const leda::graph &amp;g, leda::array&lt; leda::d_int_set &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga1f6f1484504fe60879165d0d8eab1cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a minimum cycle basis of an undirected graph using a hybrid algorithm.  <a href="group__exactmcb.html#ga1f6f1484504fe60879165d0d8eab1cbe">More...</a><br /></td></tr>
<tr class="separator:ga1f6f1484504fe60879165d0d8eab1cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa71d70d0790e602f7c8cb09021368b4"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:gaaa71d70d0790e602f7c8cb09021368b4"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#gaaa71d70d0790e602f7c8cb09021368b4">mcb::UMCB_HYBRID</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; d_int_set &gt; &amp;mcb, array&lt; d_int_set &gt; &amp;proof, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:gaaa71d70d0790e602f7c8cb09021368b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a minimum cycle basis of a weighted undirected graph using a hybrid algorithm.  <a href="group__exactmcb.html#gaaa71d70d0790e602f7c8cb09021368b4">More...</a><br /></td></tr>
<tr class="separator:gaaa71d70d0790e602f7c8cb09021368b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b9fb709d48585228bd721a4ca71bb2a"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:ga3b9fb709d48585228bd721a4ca71bb2a"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga3b9fb709d48585228bd721a4ca71bb2a">mcb::UMCB_HYBRID</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; d_int_set &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga3b9fb709d48585228bd721a4ca71bb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a minimum cycle basis of a weighted undirected graph using a hybrid algorithm.  <a href="group__exactmcb.html#ga3b9fb709d48585228bd721a4ca71bb2a">More...</a><br /></td></tr>
<tr class="separator:ga3b9fb709d48585228bd721a4ca71bb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe3a5719c2c92ddbb72da6988c7f006"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:ga2fe3a5719c2c92ddbb72da6988c7f006"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga2fe3a5719c2c92ddbb72da6988c7f006">mcb::UMCB_FH</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;mcb, array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;proof, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga2fe3a5719c2c92ddbb72da6988c7f006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a MCB of an undirected weighted graph using a Fast variant of the Hybrid algorithm.  <a href="group__exactmcb.html#ga2fe3a5719c2c92ddbb72da6988c7f006">More...</a><br /></td></tr>
<tr class="separator:ga2fe3a5719c2c92ddbb72da6988c7f006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba4cb061e19bd0ead70f05c9fc828f9"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:ga0ba4cb061e19bd0ead70f05c9fc828f9"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga0ba4cb061e19bd0ead70f05c9fc828f9">mcb::UMCB_FH</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga0ba4cb061e19bd0ead70f05c9fc828f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a MCB of an undirected weighted graph using a Fast variant of the Hybrid algorithm.  <a href="group__exactmcb.html#ga0ba4cb061e19bd0ead70f05c9fc828f9">More...</a><br /></td></tr>
<tr class="separator:ga0ba4cb061e19bd0ead70f05c9fc828f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5330118659b9aca7c06ab2cdea4b9040"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:ga5330118659b9aca7c06ab2cdea4b9040"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga5330118659b9aca7c06ab2cdea4b9040">mcb::UMCB</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga5330118659b9aca7c06ab2cdea4b9040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an MCB of an undirected graph (possible a multigraph) using the most general implementation of this library.  <a href="group__exactmcb.html#ga5330118659b9aca7c06ab2cdea4b9040">More...</a><br /></td></tr>
<tr class="separator:ga5330118659b9aca7c06ab2cdea4b9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c9e8c29677fda6bb5f26abd5686f71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga79c9e8c29677fda6bb5f26abd5686f71">mcb::UMCB</a> (const graph &amp;g, array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb)</td></tr>
<tr class="memdesc:ga79c9e8c29677fda6bb5f26abd5686f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an MCB of an undirected graph (possible a multigraph) using the most general implementation of this library.  <a href="group__exactmcb.html#ga79c9e8c29677fda6bb5f26abd5686f71">More...</a><br /></td></tr>
<tr class="separator:ga79c9e8c29677fda6bb5f26abd5686f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Directed Minimum Cycle Basis</h2></td></tr>
<tr class="memitem:ga78bbde2610d1ca5d6f3f1b78f6a0a204"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:ga78bbde2610d1ca5d6f3f1b78f6a0a204"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga78bbde2610d1ca5d6f3f1b78f6a0a204">mcb::DMCB</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; <a class="el" href="classmcb_1_1spvecfp.html">mcb::spvecfp</a> &gt; &amp;mcb, array&lt; <a class="el" href="classmcb_1_1spvecfp.html">mcb::spvecfp</a> &gt; &amp;proof, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb, double error=0.375)</td></tr>
<tr class="memdesc:ga78bbde2610d1ca5d6f3f1b78f6a0a204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a minimum cycle basis of a weighted directed graph.  <a href="group__exactmcb.html#ga78bbde2610d1ca5d6f3f1b78f6a0a204">More...</a><br /></td></tr>
<tr class="separator:ga78bbde2610d1ca5d6f3f1b78f6a0a204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e26f4ceee756b467c500c1e0b32409"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:ga29e26f4ceee756b467c500c1e0b32409"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#ga29e26f4ceee756b467c500c1e0b32409">mcb::DMCB</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; <a class="el" href="classmcb_1_1spvecfp.html">mcb::spvecfp</a> &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb, double error=0.375)</td></tr>
<tr class="memdesc:ga29e26f4ceee756b467c500c1e0b32409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a minimum cycle basis of a weighted directed graph.  <a href="group__exactmcb.html#ga29e26f4ceee756b467c500c1e0b32409">More...</a><br /></td></tr>
<tr class="separator:ga29e26f4ceee756b467c500c1e0b32409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec572c237abd349ce4bc388fa532468f"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:gaec572c237abd349ce4bc388fa532468f"><td class="memTemplItemLeft" align="right" valign="top">W&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exactmcb.html#gaec572c237abd349ce4bc388fa532468f">mcb::DMCB</a> (const graph &amp;g, const edge_array&lt; W &gt; &amp;len, array&lt; array&lt; etype &gt; &gt; &amp;mcb, const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;enumb, double error=0.375)</td></tr>
<tr class="memdesc:gaec572c237abd349ce4bc388fa532468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a minimum cycle basis of a weighted directed graph.  <a href="group__exactmcb.html#gaec572c237abd349ce4bc388fa532468f">More...</a><br /></td></tr>
<tr class="separator:gaec572c237abd349ce4bc388fa532468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga78bbde2610d1ca5d6f3f1b78f6a0a204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::DMCB </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecfp.html">mcb::spvecfp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecfp.html">mcb::spvecfp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em> = <code>0.375</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a minimum cycle basis of a weighted directed graph. </p>
<p>The function computes a directed Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of sparse vectors spvecfp, called mcb.</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function also returns a certificate of optimality of the minimum cycle basis. More precisely a set of linearly independent vectors for which cycle <img class="formulaInl" alt="$i$" src="form_24.png"/> is the shortest cycle in <img class="formulaInl" alt="$g$" src="form_23.png"/> with non-zero intersection with the proof vector <img class="formulaInl" alt="$i$" src="form_24.png"/>.</p>
<p>Since the algorithm is a randomized Monte-Carlo algorithm, the error argument which should be less that 1 represents the acceptable error probability that the returned cycle basis is not a minimum cycle basis.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.</p>
<p>The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A directed graph. </td></tr>
    <tr><td class="paramname">len</td><td>The edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of spvecfp to return the MCB. </td></tr>
    <tr><td class="paramname">proof</td><td>A leda::array of spvecfp to return the proof. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
    <tr><td class="paramname">error</td><td>The error probability. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is simple and loop-free </dd>
<dd>
len is positive </dd>
<dd>
enumb is already initialized with g </dd>
<dd>
error is positive and less than one </dd></dl>

<p>References <a class="el" href="classmcb_1_1edge__num.html#a6ce805ed1fbb8ac6fb1f2f605fedfe24">mcb::edge_num::dim_cycle_space()</a>.</p>

</div>
</div>
<a class="anchor" id="ga29e26f4ceee756b467c500c1e0b32409"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::DMCB </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecfp.html">mcb::spvecfp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em> = <code>0.375</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a minimum cycle basis of a weighted directed graph. </p>
<p>The function computes a directed Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of sparse vectors spvecfp, called mcb.</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>Since the algorithm is a randomized Monte-Carlo algorithm, the error argument which should be less that 1 represents the acceptable error probability that the returned cycle basis is not a minimum cycle basis.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.</p>
<p>The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A directed graph. </td></tr>
    <tr><td class="paramname">len</td><td>The edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of spvecfp to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
    <tr><td class="paramname">error</td><td>The error probability. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is simple and loop-free </dd>
<dd>
len is positive </dd>
<dd>
enumb is already initialized with g </dd>
<dd>
error is positive and less than one </dd></dl>

</div>
</div>
<a class="anchor" id="gaec572c237abd349ce4bc388fa532468f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::DMCB </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; array&lt; etype &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em> = <code>0.375</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a minimum cycle basis of a weighted directed graph. </p>
<p>The function computes a directed Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of arrays of integers. Each such array if indexed on <img class="formulaInl" alt="$1 \dots m$" src="form_36.png"/> and its entry can be <img class="formulaInl" alt="$0$" src="form_7.png"/> or <img class="formulaInl" alt="$\pm 1$" src="form_37.png"/>. Which edge corresponds to which index in this array can be found by the edge numbering, enumb. Note that the edge numbering using an indexing from <img class="formulaInl" alt="$0$" src="form_7.png"/> to <img class="formulaInl" alt="$m-1$" src="form_8.png"/>.</p>
<p>Since the algorithm is a randomized Monte-Carlo algorithm, the error argument which should be less that 1 represents the acceptable error probability that the returned cycle basis is not a minimum cycle basis.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.</p>
<p>The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A directed graph. </td></tr>
    <tr><td class="paramname">len</td><td>The edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of leda::arrays of ints to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
    <tr><td class="paramname">error</td><td>The error probability. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is simple and loop-free </dd>
<dd>
len is positive </dd>
<dd>
enumb is already initialized with g </dd>
<dd>
error is positive and less than one </dd></dl>

<p>References <a class="el" href="classmcb_1_1edge__num.html#a6ce805ed1fbb8ac6fb1f2f605fedfe24">mcb::edge_num::dim_cycle_space()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5330118659b9aca7c06ab2cdea4b9040"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::UMCB </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an MCB of an undirected graph (possible a multigraph) using the most general implementation of this library. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of mcb:<a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">spvecgf2</a> objects.<br />
 Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">len</td><td>The edge lengths function. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a> to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Care must be taken when the template parameter is instantiated with a data type which has rounding errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79c9e8c29677fda6bb5f26abd5686f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::UMCB </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an MCB of an undirected graph (possible a multigraph) using the most general implementation of this library. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of mcb:<a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">spvecgf2</a> objects.<br />
 Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a> to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Care must be taken when the template parameter is instantiated with a data type which has rounding errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fe3a5719c2c92ddbb72da6988c7f006"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::UMCB_FH </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a MCB of an undirected weighted graph using a Fast variant of the Hybrid algorithm. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). It accepts the length type as a template parameter. The basis is returned as an array of <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a> objects.<br />
</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb. The function also returns a certificate of optimality of the minimum cycle basis. More precisely a set of linearly independent vectors for which cycle <img class="formulaInl" alt="$i$" src="form_24.png"/> is the shortest cycle in <img class="formulaInl" alt="$g$" src="form_23.png"/> with odd intersection with the proof vector <img class="formulaInl" alt="$i$" src="form_24.png"/>.<br />
</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">len</td><td>A leda::edge_array for the edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a> to return the MCB. </td></tr>
    <tr><td class="paramname">proof</td><td>A leda::array of <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a> to return the proof. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree. </dd>
<dd>
len is non-negative </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Care must be taken when the template parameter is instantiated with a data type which has rounding errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ba4cb061e19bd0ead70f05c9fc828f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::UMCB_FH </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a MCB of an undirected weighted graph using a Fast variant of the Hybrid algorithm. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). It accepts the length type as a template parameter. The basis is returned as an array of <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a> objects.<br />
</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">len</td><td>A leda::edge_array for the edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a> to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree. </dd>
<dd>
len is non-negative </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Care must be taken when the template parameter is instantiated with a data type which has rounding errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga23c6c771dd268b9943b310fa48d72792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::UMCB_HYBRID </td>
          <td>(</td>
          <td class="paramtype">const leda::graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">leda::array&lt; leda::d_int_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">leda::array&lt; leda::d_int_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a minimum cycle basis of an undirected graph using a hybrid algorithm. </p>
<p>The function computes a minimum cycle basis of an undirected graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of dynamic integer sets, d_int_set, called mcb.</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function also returns a certificate of optimality of the minimum cycle basis. More precisely a set of linearly independent vectors for which cycle <img class="formulaInl" alt="$i$" src="form_24.png"/> is the shortest cycle in <img class="formulaInl" alt="$g$" src="form_23.png"/> with odd intersection with the proof vector <img class="formulaInl" alt="$i$" src="form_24.png"/>.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^2 n^2 )$" src="form_26.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/> and <img class="formulaInl" alt="$n$" src="form_27.png"/> the number of vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of leda::d_int_set to return the MCB. </td></tr>
    <tr><td class="paramname">proof</td><td>A leda::array of leda::d_int_set to return the proof. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree </dd></dl>

<p>Referenced by <a class="el" href="group__exactmcb.html#ga3b9fb709d48585228bd721a4ca71bb2a">mcb::UMCB_HYBRID()</a>, and <a class="el" href="group__exactmcb.html#ga366093168b1b16f19b79fb6741d0c9f5">mcb::UMCB_SVA()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f6f1484504fe60879165d0d8eab1cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::UMCB_HYBRID </td>
          <td>(</td>
          <td class="paramtype">const leda::graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">leda::array&lt; leda::d_int_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a minimum cycle basis of an undirected graph using a hybrid algorithm. </p>
<p>The function computes a minimum cycle basis of an undirected graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of dynamic integer sets, d_int_set, called mcb.</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^2 n^2 )$" src="form_26.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/> and <img class="formulaInl" alt="$n$" src="form_27.png"/> the number of vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of leda::d_int_set to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa71d70d0790e602f7c8cb09021368b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::UMCB_HYBRID </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; d_int_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; d_int_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a minimum cycle basis of a weighted undirected graph using a hybrid algorithm. </p>
<p>The function computes a minimum cycle basis of an undirected weighted graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of dynamic integer sets, d_int_set, called mcb.</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function also returns a certificate of optimality of the minimum cycle basis. More precisely a set of linearly independent vectors for which cycle <img class="formulaInl" alt="$i$" src="form_24.png"/> is the shortest cycle in <img class="formulaInl" alt="$g$" src="form_23.png"/> with odd intersection with the proof vector <img class="formulaInl" alt="$i$" src="form_24.png"/>.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^2 n^2 )$" src="form_26.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/> and <img class="formulaInl" alt="$n$" src="form_27.png"/> the number of vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">len</td><td>A leda::edge_array for the edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of leda::d_int_set to return the MCB. </td></tr>
    <tr><td class="paramname">proof</td><td>A leda::array of leda::d_int_set to return the proof. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree </dd>
<dd>
len is non-negative </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b9fb709d48585228bd721a4ca71bb2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::UMCB_HYBRID </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; d_int_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a minimum cycle basis of a weighted undirected graph using a hybrid algorithm. </p>
<p>The function computes a minimum cycle basis of an undirected weighted graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). The basis is returned as an array of dynamic integer sets, d_int_set, called mcb.</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^2 n^2 )$" src="form_26.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/> and <img class="formulaInl" alt="$n$" src="form_27.png"/> the number of vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">len</td><td>A leda::edge_array for the edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of leda::d_int_set to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree </dd>
<dd>
len is non-negative </dd></dl>

<p>References <a class="el" href="group__exactmcb.html#ga23c6c771dd268b9943b310fa48d72792">mcb::UMCB_HYBRID()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0d7063e6370d4faed9fe384c04260b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int mcb::UMCB_SVA </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a MCB of an undirected graph using the Support Vector Approach (de Pina's PhD thesis) algorithm. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). It accepts one template parameter which is the container to use for recording the cycles. Currently two options are accepted, leda::d_int_set and <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a>. The basis is returned as an array of Container objects.<br />
</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb. The function also returns a certificate of optimality of the minimum cycle basis. More precisely a set of linearly independent vectors for which cycle <img class="formulaInl" alt="$i$" src="form_24.png"/> is the shortest cycle in <img class="formulaInl" alt="$g$" src="form_23.png"/> with odd intersection with the proof vector <img class="formulaInl" alt="$i$" src="form_24.png"/>.<br />
</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of Container to return the MCB. </td></tr>
    <tr><td class="paramname">proof</td><td>A leda::array of Container to return the proof. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree. </dd></dl>

<p>Referenced by <a class="el" href="group__exactmcb.html#ga1e1b28748379d953fea05043cfc74beb">mcb::UMCB_SVA()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e1b28748379d953fea05043cfc74beb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int mcb::UMCB_SVA </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a MCB of an undirected weighted graph using the Support Vector Approach (de Pina's PhD thesis) algorithm. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). It accepts one template parameters which is the container to use for recording the cycles. Currently two options are accepted, leda::d_int_set and <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a>. The basis is returned as an array of Container objects.<br />
</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.<br />
</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of Container to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree. </dd></dl>

<p>References <a class="el" href="group__exactmcb.html#gaf0d7063e6370d4faed9fe384c04260b4">mcb::UMCB_SVA()</a>.</p>

</div>
</div>
<a class="anchor" id="ga624d6f56bd60699e61d74deaa459e4da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::UMCB_SVA </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a MCB of an undirected weighted graph using the Support Vector Approach (de Pina's PhD thesis) algorithm. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). It accepts two template parameters. The first is length type and the second is the container to use for recording the cycles. Currently two options are accepted, leda::d_int_set and <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a>. The basis is returned as an array of Container objects.<br />
</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb. The function also returns a certificate of optimality of the minimum cycle basis. More precisely a set of linearly independent vectors for which cycle <img class="formulaInl" alt="$i$" src="form_24.png"/> is the shortest cycle in <img class="formulaInl" alt="$g$" src="form_23.png"/> with odd intersection with the proof vector <img class="formulaInl" alt="$i$" src="form_24.png"/>.<br />
</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">len</td><td>A leda::edge_array for the edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of Container to return the MCB. </td></tr>
    <tr><td class="paramname">proof</td><td>A leda::array of Container to return the proof. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree. </dd>
<dd>
len is non-negative </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Care must be taken when the template parameter is instantiated with a data type which has rounding errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga366093168b1b16f19b79fb6741d0c9f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class W , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">W mcb::UMCB_SVA </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const edge_array&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1edge__num.html">mcb::edge_num</a> &amp;&#160;</td>
          <td class="paramname"><em>enumb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a MCB of an undirected weighted graph using the Support Vector Approach (de Pina's PhD thesis) algorithm. </p>
<p>The function computes a Minimum Cycle Basis <img class="formulaInl" alt="$B$" src="form_22.png"/> of a graph <img class="formulaInl" alt="$g$" src="form_23.png"/>, that is a cycle basis of <img class="formulaInl" alt="$g$" src="form_23.png"/> with the smallest length (sum of lengths of cycles). It accepts two template parameters. The first is length type and the second is the container to use for recording the cycles. Currently two options are accepted, leda::d_int_set and <a class="el" href="classmcb_1_1spvecgf2.html" title="A sparse vector with elements in GF2. ">mcb::spvecgf2</a>. The basis is returned as an array of Container objects.<br />
</p>
<p>Every edge is represented by some integer, by a fixed and arbitrary numbering. This numbering is represented by enumb.</p>
<p>The function returns the weight of the Minimum Cycle Basis or is undefined if there were any errors.<br />
 The running time is <img class="formulaInl" alt="$O( m^3 )$" src="form_25.png"/> where <img class="formulaInl" alt="$m$" src="form_6.png"/> are the number of edges of <img class="formulaInl" alt="$g$" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An undirected graph. </td></tr>
    <tr><td class="paramname">len</td><td>A leda::edge_array for the edge lengths. </td></tr>
    <tr><td class="paramname">mcb</td><td>A leda::array of Container to return the MCB. </td></tr>
    <tr><td class="paramname">enumb</td><td>An edge numbering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCB or undefined if some error occured. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>g is undirected, simple and loopfree. </dd>
<dd>
len is non-negative </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Care must be taken when the template parameter is instantiated with a data type which has rounding errors. </dd></dl>

<p>References <a class="el" href="group__exactmcb.html#ga23c6c771dd268b9943b310fa48d72792">mcb::UMCB_HYBRID()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
