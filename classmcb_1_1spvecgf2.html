<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mcb LEDA Extension Package: mcb::spvecgf2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mcb LEDA Extension Package
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemcb.html">mcb</a></li><li class="navelem"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classmcb_1_1spvecgf2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mcb::spvecgf2 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A sparse vector with elements in GF2.  
 <a href="classmcb_1_1spvecgf2.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spvecgf2_8h_source.html">spvecgf2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa1faa1073928b559a2af0f397aaf43ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#aa1faa1073928b559a2af0f397aaf43ad">spvecgf2</a> ()</td></tr>
<tr class="separator:aa1faa1073928b559a2af0f397aaf43ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c74001e117748f301917bc1e94bd0eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a3c74001e117748f301917bc1e94bd0eb">spvecgf2</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a)</td></tr>
<tr class="separator:a3c74001e117748f301917bc1e94bd0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c6cdc00a3162bc53d31f06337ed925"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#ab1c6cdc00a3162bc53d31f06337ed925">~spvecgf2</a> ()</td></tr>
<tr class="separator:ab1c6cdc00a3162bc53d31f06337ed925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acfd7d469c21f53661188de9fbc38fa3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#acfd7d469c21f53661188de9fbc38fa3c">operator=</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;i)</td></tr>
<tr class="separator:acfd7d469c21f53661188de9fbc38fa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96877c53b392fa74d460fd0a1e9c045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#aa96877c53b392fa74d460fd0a1e9c045">operator=</a> (const int &amp;i)</td></tr>
<tr class="separator:aa96877c53b392fa74d460fd0a1e9c045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f75218762f141f7f2b293473ba1ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a37f75218762f141f7f2b293473ba1ed0">operator=</a> (d_int_set &amp;i)</td></tr>
<tr class="separator:a37f75218762f141f7f2b293473ba1ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a9a5a5c6e0b6e29d1c388e2d1bd8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#aa50a9a5a5c6e0b6e29d1c388e2d1bd8f">operator-</a> () const </td></tr>
<tr class="separator:aa50a9a5a5c6e0b6e29d1c388e2d1bd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f045ec5e47131fc1704f5be02a061"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#af28f045ec5e47131fc1704f5be02a061">operator*</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a) const </td></tr>
<tr class="separator:af28f045ec5e47131fc1704f5be02a061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31bf9ad73402df303b779240aa4b863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#aa31bf9ad73402df303b779240aa4b863">operator+</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a) const </td></tr>
<tr class="separator:aa31bf9ad73402df303b779240aa4b863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2ceb25ad87c0e24535e7d1df1ba6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a6a2ceb25ad87c0e24535e7d1df1ba6d6">add</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a)</td></tr>
<tr class="separator:a6a2ceb25ad87c0e24535e7d1df1ba6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7b9552f6147f4f796d0d296ec7b367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#afe7b9552f6147f4f796d0d296ec7b367">operator%</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a) const </td></tr>
<tr class="separator:afe7b9552f6147f4f796d0d296ec7b367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd1d70d4df807a21723d2170183681"><td class="memItemLeft" align="right" valign="top">d_int_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#ad9bd1d70d4df807a21723d2170183681">operator%</a> (const d_int_set &amp;a) const </td></tr>
<tr class="separator:ad9bd1d70d4df807a21723d2170183681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5557b9cdaa11f90734b350b54e9fc721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a5557b9cdaa11f90734b350b54e9fc721">intersect</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a) const </td></tr>
<tr class="separator:a5557b9cdaa11f90734b350b54e9fc721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5b6dfc78d2e47eca5631f524be4d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a0a5b6dfc78d2e47eca5631f524be4d59">operator+=</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a)</td></tr>
<tr class="separator:a0a5b6dfc78d2e47eca5631f524be4d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800147b9c988b4576a0c2a0344576442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a800147b9c988b4576a0c2a0344576442">operator-=</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a)</td></tr>
<tr class="separator:a800147b9c988b4576a0c2a0344576442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8206e5455a7ab87153a546fa75139c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a8206e5455a7ab87153a546fa75139c3c">operator%=</a> (const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a)</td></tr>
<tr class="separator:a8206e5455a7ab87153a546fa75139c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8305905df6c0324aa0e95f198cc1de96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a8305905df6c0324aa0e95f198cc1de96">swap</a> (<a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;a)</td></tr>
<tr class="separator:a8305905df6c0324aa0e95f198cc1de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a15035858caa00c2c3fd3db75991f76fa"><td class="memItemLeft" align="right" valign="top">d_int_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a15035858caa00c2c3fd3db75991f76fa">to_d_int_set</a> () const </td></tr>
<tr class="separator:a15035858caa00c2c3fd3db75991f76fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3583e684c5f186be0f37fca728646e2a"><td class="memItemLeft" align="right" valign="top">list&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a3583e684c5f186be0f37fca728646e2a">to_list</a> () const </td></tr>
<tr class="separator:a3583e684c5f186be0f37fca728646e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a04b4115b1c7996ee1da15f7b6d902c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a04b4115b1c7996ee1da15f7b6d902c19">clear</a> ()</td></tr>
<tr class="separator:a04b4115b1c7996ee1da15f7b6d902c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaadd733fb89ebc219b37569f37ac04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#adbaadd733fb89ebc219b37569f37ac04">print</a> (std::ostream &amp;o) const </td></tr>
<tr class="separator:adbaadd733fb89ebc219b37569f37ac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d23bf548c7625c5cff7f6ce348fdc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append</a> (int <a class="el" href="classmcb_1_1spvecgf2.html#ab9f9177de31c43747a959b8c47f18e5b">index</a>)</td></tr>
<tr class="separator:ab2d23bf548c7625c5cff7f6ce348fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d7779acec75faf36adb386f1a7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert</a> (int <a class="el" href="classmcb_1_1spvecgf2.html#ab9f9177de31c43747a959b8c47f18e5b">index</a>)</td></tr>
<tr class="separator:a8d3d7779acec75faf36adb386f1a7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8486dd7112c88c9cb8c747b78b5211"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#aed8486dd7112c88c9cb8c747b78b5211">pop</a> ()</td></tr>
<tr class="separator:aed8486dd7112c88c9cb8c747b78b5211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5675adb00e8bd65f6b875374bb8328d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort</a> ()</td></tr>
<tr class="separator:aa5675adb00e8bd65f6b875374bb8328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e7b1852edab89dd6289378337bdae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a67e7b1852edab89dd6289378337bdae1">empty</a> () const </td></tr>
<tr class="separator:a67e7b1852edab89dd6289378337bdae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e503659ed1d56ab7c971a68adcc9c4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a7e503659ed1d56ab7c971a68adcc9c4a">size</a> () const </td></tr>
<tr class="separator:a7e503659ed1d56ab7c971a68adcc9c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac422b01a62da086a9ef975388918e839"><td class="memItemLeft" align="right" valign="top">list_item&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#ac422b01a62da086a9ef975388918e839">first</a> () const </td></tr>
<tr class="separator:ac422b01a62da086a9ef975388918e839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7211f9116172a8cb90d45e45d768a5"><td class="memItemLeft" align="right" valign="top">list_item&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a3c7211f9116172a8cb90d45e45d768a5">last</a> () const </td></tr>
<tr class="separator:a3c7211f9116172a8cb90d45e45d768a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418d1aade7c3202c7d1bca119c3d1ae0"><td class="memItemLeft" align="right" valign="top">list_item&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a418d1aade7c3202c7d1bca119c3d1ae0">succ</a> (list_item it) const </td></tr>
<tr class="separator:a418d1aade7c3202c7d1bca119c3d1ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4189b9db0972f0640874046356cd8f84"><td class="memItemLeft" align="right" valign="top">list_item&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a4189b9db0972f0640874046356cd8f84">pred</a> (list_item it) const </td></tr>
<tr class="separator:a4189b9db0972f0640874046356cd8f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f9177de31c43747a959b8c47f18e5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#ab9f9177de31c43747a959b8c47f18e5b">index</a> (list_item it) const </td></tr>
<tr class="separator:ab9f9177de31c43747a959b8c47f18e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790d17d027ae6d541ecfaade2149685e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcb_1_1spvecgf2.html#a790d17d027ae6d541ecfaade2149685e">inf</a> (list_item it) const </td></tr>
<tr class="separator:a790d17d027ae6d541ecfaade2149685e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A sparse vector with elements in GF2. </p>
<p>An object of this class represents a cycle of an undirected graph. It behaves as a sparse matrix of values in GF(2).</p>
<p>This class is implemented internally by double linked lists. The internal representation is a list of integers representing the indexes where the vector has a one. The indexes are stored in increasing order. Operations append and insert take constant time but do not ensure the correct ordering of the elements. See <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a> for reconstructing this ordering.</p>
<p>Most binary operations take time proportional to the number of elements in the list by assumming that the indexes are stored in increasing order. Size, empty, clear and the iterators' methods take constant time. Swap also takes constant time.</p>
<p>Such an object can be accessed in exactly the same manner that a list of LEDA is accessed. Each one in the sparse vector corresponds in a list_item in a list. Thus, the following is valid: </p><div class="fragment"><div class="line"><a class="code" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> v;</div><div class="line"><span class="keywordtype">int</span> i;</div><div class="line">leda::list_item li = v.<a class="code" href="classmcb_1_1spvecgf2.html#ac422b01a62da086a9ef975388918e839">first</a>();</div><div class="line"><span class="keywordflow">while</span>( li != NULL ) { </div><div class="line">    i = v.<a class="code" href="classmcb_1_1spvecgf2.html#ab9f9177de31c43747a959b8c47f18e5b">index</a>( li );</div><div class="line">    <span class="comment">// do something with i</span></div><div class="line">    li = v.<a class="code" href="classmcb_1_1spvecgf2.html#a418d1aade7c3202c7d1bca119c3d1ae0">succ</a>( li );</div><div class="line">}</div></div><!-- fragment --><p>LEDA's forall macro works for this objects. It can be used in the following way: </p><div class="fragment"><div class="line"><a class="code" href="classmcb_1_1spvecgf2.html">mcb::spvecgf2</a> v;</div><div class="line"><span class="keywordtype">int</span> i;</div><div class="line">forall(i,v) { </div><div class="line">    <span class="comment">// do something with i</span></div><div class="line">}</div></div><!-- fragment --><dl class="section date"><dt>Date</dt><dd>2005 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Dimitris Michail </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa1faa1073928b559a2af0f397aaf43ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mcb::spvecgf2::spvecgf2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a3c74001e117748f301917bc1e94bd0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mcb::spvecgf2::spvecgf2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="ab1c6cdc00a3162bc53d31f06337ed925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mcb::spvecgf2::~spvecgf2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6a2ceb25ad87c0e24535e7d1df1ba6d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcb::spvecgf2::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a vector to the current vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The vector to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2d23bf548c7625c5cff7f6ce348fdc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcb::spvecgf2::append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append an entry, without checking for proper order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An integer representing that the sparse vector has a one at that position. Indexing should start from zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The internal representation of this object is an ordered list of integers. This function however makes no attempt to ensure such an ordering, it only appends the new entry into the list. Use wisely. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a> </dd></dl>

<p>Referenced by <a class="el" href="classmcb_1_1spvecgf2.html#a04b4115b1c7996ee1da15f7b6d902c19">clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a04b4115b1c7996ee1da15f7b6d902c19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mcb::spvecgf2::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the set. </p>

<p>References <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab9f9177de31c43747a959b8c47f18e5b">index()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, and <a class="el" href="classmcb_1_1spvecgf2.html#adbaadd733fb89ebc219b37569f37ac04">print()</a>.</p>

</div>
</div>
<a class="anchor" id="a67e7b1852edab89dd6289378337bdae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mcb::spvecgf2::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if empty. </p><dl class="section return"><dt>Returns</dt><dd>True if empty, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac422b01a62da086a9ef975388918e839"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_item mcb::spvecgf2::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first item of the sparse vector. Each item represents a position where the sparse vector has a one. </p><dl class="section return"><dt>Returns</dt><dd>Returns the first item of the vector. This item is a list_item of LEDA's list representation. NULL is returned if the vector contains no elements. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9f9177de31c43747a959b8c47f18e5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::spvecgf2::index </td>
          <td>(</td>
          <td class="paramtype">list_item&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index of an item. Each item represents a one in the sparse vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of this one in the sparse vector. </dd></dl>

<p>Referenced by <a class="el" href="classmcb_1_1spvecgf2.html#a04b4115b1c7996ee1da15f7b6d902c19">clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a790d17d027ae6d541ecfaade2149685e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::spvecgf2::inf </td>
          <td>(</td>
          <td class="paramtype">list_item&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index of an item. Each item represents a one in the sparse vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of this one in the sparse vector. </dd></dl>

<p>References <a class="el" href="namespacemcb.html#a7798e965e1f47991f99a187fd33654aa">mcb::operator&lt;&lt;()</a>, and <a class="el" href="namespacemcb.html#a1cdb8e37c0a95c9c08b7ad23a4bc908f">mcb::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3d7779acec75faf36adb386f1a7ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcb::spvecgf2::insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append an entry, without checking for proper order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An integer representing that the sparse vector has a one at that position. Indexing should start from zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The internal representation of this object is an ordered list of integers. This function however makes no attempt to ensure such an ordering, it only appends the new entry into the list. Use wisely. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a> </dd></dl>

<p>Referenced by <a class="el" href="classmcb_1_1spvecgf2.html#a04b4115b1c7996ee1da15f7b6d902c19">clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a5557b9cdaa11f90734b350b54e9fc721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> mcb::spvecgf2::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the intersection of this vector and a. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection of the current object and a. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c7211f9116172a8cb90d45e45d768a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_item mcb::spvecgf2::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the last item of the sparse vector. Each item represents a position where the sparse vector has a one. </p><dl class="section return"><dt>Returns</dt><dd>Returns the last item of the vector. This item is a list_item of LEDA's list representation. NULL is returned if the vector contains no elements. </dd></dl>

</div>
</div>
<a class="anchor" id="afe7b9552f6147f4f796d0d296ec7b367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> mcb::spvecgf2::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator to compute the symmetric difference of this sparse vector and of a. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric difference as a new sparse vector. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9bd1d70d4df807a21723d2170183681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">d_int_set mcb::spvecgf2::operator% </td>
          <td>(</td>
          <td class="paramtype">const d_int_set &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator to compute the symmetric difference of this sparse vector and of a LEDA dynamic integer set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A dynamic integer set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric difference as a new dynamic integer set. </dd></dl>

</div>
</div>
<a class="anchor" id="a8206e5455a7ab87153a546fa75139c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&amp; mcb::spvecgf2::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign to the current vector the symmetric difference of the current vector an vector a. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An input sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current vector after the symmetric difference operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af28f045ec5e47131fc1704f5be02a061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::spvecgf2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute inner product. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input vector a. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product of this object and a. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa31bf9ad73402df303b779240aa4b863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> mcb::spvecgf2::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator to add the current vector with another vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The second vector to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector representing the sum. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a5b6dfc78d2e47eca5631f524be4d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&amp; mcb::spvecgf2::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a vector to the current vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The vector to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current vector after the addition. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa50a9a5a5c6e0b6e29d1c388e2d1bd8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> mcb::spvecgf2::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Negate the current vector. </p><dl class="section return"><dt>Returns</dt><dd>A new object representing the current vector negated. </dd></dl>

</div>
</div>
<a class="anchor" id="a800147b9c988b4576a0c2a0344576442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&amp; mcb::spvecgf2::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a vector to the current vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The vector to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current vector after the addition. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Subtracting and addition is the same in GF(2). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes a sorted representation. See <a class="el" href="classmcb_1_1spvecgf2.html#a8d3d7779acec75faf36adb386f1a7ded">insert()</a>, <a class="el" href="classmcb_1_1spvecgf2.html#ab2d23bf548c7625c5cff7f6ce348fdc7">append()</a> and <a class="el" href="classmcb_1_1spvecgf2.html#aa5675adb00e8bd65f6b875374bb8328d">sort()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acfd7d469c21f53661188de9fbc38fa3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&amp; mcb::spvecgf2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a vector to another vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The vector to assign from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current vector after the assignment. </dd></dl>

</div>
</div>
<a class="anchor" id="aa96877c53b392fa74d460fd0a1e9c045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&amp; mcb::spvecgf2::operator= </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign current vector to be <img class="formulaInl" alt="$e_i$" src="form_16.png"/>. </p>

</div>
</div>
<a class="anchor" id="a37f75218762f141f7f2b293473ba1ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a>&amp; mcb::spvecgf2::operator= </td>
          <td>(</td>
          <td class="paramtype">d_int_set &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator for a leda::d_int_set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>A compressed integer set of LEDA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The currect sparse vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aed8486dd7112c88c9cb8c747b78b5211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::spvecgf2::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete the first entry of the sparse vector and return its index. </p><dl class="section return"><dt>Returns</dt><dd>The index of the first entry which was deleted. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The sparse array should not be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a4189b9db0972f0640874046356cd8f84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_item mcb::spvecgf2::pred </td>
          <td>(</td>
          <td class="paramtype">list_item&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the predecessor of an item. Each item represents a position where the sparse vector has a one. </p><dl class="section return"><dt>Returns</dt><dd>The predecessor of an item, NULL if sparse vector is empty. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>it is an item of the current object. </dd></dl>

</div>
</div>
<a class="anchor" id="adbaadd733fb89ebc219b37569f37ac04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcb::spvecgf2::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a sparse vector to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The stream to print to. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classmcb_1_1spvecgf2.html#a04b4115b1c7996ee1da15f7b6d902c19">clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e503659ed1d56ab7c971a68adcc9c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mcb::spvecgf2::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get size of sparse vector. </p><dl class="section return"><dt>Returns</dt><dd>The size of the sparse vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5675adb00e8bd65f6b875374bb8328d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mcb::spvecgf2::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sort the internal representation of the sparse vector. This operation ensures that a correct representation after its call. Should not be necessary unless insert or append were called in wrong order. Note that this function does not make sure the entries are unique. </p>

</div>
</div>
<a class="anchor" id="a418d1aade7c3202c7d1bca119c3d1ae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_item mcb::spvecgf2::succ </td>
          <td>(</td>
          <td class="paramtype">list_item&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the successor of an item. Each item represents a position where the sparse vector has a one. </p><dl class="section return"><dt>Returns</dt><dd>The successor of an item, NULL if sparse vector is empty. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>it is an item of the current object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8305905df6c0324aa0e95f198cc1de96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcb::spvecgf2::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmcb_1_1spvecgf2.html">spvecgf2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap two sparse vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A sparse vector to swap with the current object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is a constant time operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a15035858caa00c2c3fd3db75991f76fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">d_int_set mcb::spvecgf2::to_d_int_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the sparse vector to a LEDA dynamic integer set. </p><dl class="section return"><dt>Returns</dt><dd>A dynamic integer set. </dd></dl>

</div>
</div>
<a class="anchor" id="a3583e684c5f186be0f37fca728646e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;int&gt; mcb::spvecgf2::to_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform the sparse vector to a list of integers. </p><dl class="section return"><dt>Returns</dt><dd>A LEDA list of integers. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
