<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mcb LEDA Extension Package: Minimum Cycle Basis Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mcb LEDA Extension Package
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Minimum Cycle Basis Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>A minimum cycle basis is a basis of the cycle space of a graph with minimum weight. The weight of a minimum cycle basis is the sum of the weights of its cycles and the weight of a cycle is the sum of the weights of its edges.</p>
<p>This package contains implementations of exact and approximate algorithms to compute minimum cycle bases for weighted directed and undirected graphs.</p>
<h1><a class="anchor" id="alg_sec"></a>
Algorithms</h1>
<h2><a class="anchor" id="undir_alg_subsec"></a>
Undirected Graphs</h2>
<ul>
<li>An <img class="formulaInl" alt="$O(m^3+mn^2 \log{n})$" src="form_0.png"/> algorithm which appeared in the PhD thesis of J.C. de Pina. A description of this algorithm and an even faster one can be found <a href="http://dx.doi.org/10.1007/s00453-007-9064-z">here</a>.</li>
<li>An <img class="formulaInl" alt="$O(m^2n^2)$" src="form_1.png"/> hybrid algorithm, which is a mixture of the above algorithm and an older algorithm due to Horton. For more details see <a href="http://dx.doi.org/10.1145/1187436.1216582">here</a>.</li>
<li>An <img class="formulaInl" alt="$O(m^3)$" src="form_2.png"/> hybrid algorithm, which is a more clever implementation of the last mentioned algorithm. For more details see this <a href="http://dx.doi.org/10.1145/1644015.1644023">paper</a>.</li>
<li>An <img class="formulaInl" alt="$O( m n^{1+1/k} + \min(m^3+mn^2 \log n, n^{3+3/k}))$" src="form_3.png"/> constant factor <img class="formulaInl" alt="$(2k-1)$" src="form_4.png"/>-approximate algorithm. For more details see <a href="http://www.springerlink.com/content/740w28k651vx26l8">this link</a>.</li>
</ul>
<h2><a class="anchor" id="dir_alg_subsec"></a>
Directed Graphs</h2>
<ul>
<li>An <img class="formulaInl" alt="$O(m^3+mn^2 \log{n})$" src="form_0.png"/> implementation of an <img class="formulaInl" alt="$O(m^2 n \log{n})$" src="form_5.png"/> randomized Monte Carlo algorithm due to T. Kavitha, which appeared in ICALP'05.</li>
<li>An <img class="formulaInl" alt="$O( m n^{1+1/k} + \min(m^3+mn^2 \log n, n^{3+3/k}))$" src="form_3.png"/> constant factor <img class="formulaInl" alt="$(2k-1)$" src="form_4.png"/>-approximate algorithm. For more details see <a href="http://www.springerlink.com/content/740w28k651vx26l8">this link</a>.</li>
</ul>
<h1><a class="anchor" id="req_sec"></a>
Requirements</h1>
<p>This implementation is written in C++ and uses <a href="http://www.algorithmic-solutions.com/enleda.htm">LEDA</a>. The structure of the package follows that of a LEDA extension package (<a href="http://www.algorithmic-solutions.com/enleps.htm">LEP</a>).</p>
<h1><a class="anchor" id="platf_sec"></a>
Supported Platforms</h1>
<p>Some versions of the package have been tested on the following platforms:</p><ol type="1">
<li>gcc 3.x, 4.0.x and 4.1.x under Linux</li>
<li>gcc 3.x under SunOS 5.9</li>
<li>gcc 3.x under Cygwin</li>
<li>bcc32 5.5 under Windows</li>
<li>Visual Studio .NET 2003</li>
</ol>
<p>but it may work on others too.</p>
<h1><a class="anchor" id="lic_sec"></a>
License</h1>
<pre class="fragment"> This program can be freely used in an academic environment
 ONLY for research purposes, subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software
    an acknowledgment in the product documentation is required.
 2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.
 3. This notice may not be removed or altered from any source distribution.

 Any other use is strictly prohibited by the author, without an explicit
 permission.

 This software is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</pre><p>Note that this package uses LEDA, which is <a href="http://www.algorithmic-solutions.com/enledalizenzen.htm">not free</a>. However, Algorithmic Solutions released a <a href="http://www.algorithmic-solutions.com/leda/ledak/index.htm">free version</a> of LEDA 6.0 which can be used to build this library.</p>
<h1><a class="anchor" id="news_sec"></a>
News</h1>
<ul>
<li>18 April 2008: v0.8 released<ul>
<li>LEDA 6.0 and LEDA 6.0 free support</li>
<li>Interface change (not compatible with previous versions)</li>
<li>A lot of improvements and new features.</li>
<li>Improved demo program.</li>
</ul>
</li>
<li>1 December 2006: v0.7 released<ul>
<li>Constant factor approximation algorithms for undirected and directed graphs.</li>
<li>Interface change (not compatible with previous versions)</li>
</ul>
</li>
<li>30 March 2006: v0.6 released<ul>
<li>Support for Microsoft VC++ 7.1 compiler.</li>
</ul>
</li>
<li>27 Oct 2005: v0.5 released<ul>
<li>Speed improvements.</li>
<li>Build system improvements.</li>
</ul>
</li>
<li>30 June 2005: v0.4 released<ul>
<li>The code now is by default compiled with -O2 optimization flag.</li>
<li>Minor fixes.</li>
</ul>
</li>
<li>30 May 2005: v0.3 released<ul>
<li>Added algorithm for the directed case, still in BETA phase.</li>
<li>Improved support for LEDA 5.0, including support on windows platform.</li>
</ul>
</li>
<li>21 Mar 2005: v0.2 released<ul>
<li>minor changes in demo program.</li>
</ul>
</li>
<li>24 Feb 2005: v0.1 released</li>
</ul>
<h1><a class="anchor" id="down_sec"></a>
Download</h1>
<ul>
<li>Source package (v0.8). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.8.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.7). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.7.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.6). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.6.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.5). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.5.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.4). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.4.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.3). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.3.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.2). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.2.tar.gz">tar.gz</a>]</li>
<li>Source package (v0.1). [<a href="https://github.com/d-michail/mcb/archive/mcb-0.1.tar.gz">tar.gz</a>]</li>
</ul>
<h1><a class="anchor" id="ex_sec"></a>
Code Examples</h1>
<h2><a class="anchor" id="ex_undir"></a>
Undirected MCB</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mcb_8h.html">LEP/mcb/mcb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    leda::graph G;</div><div class="line"></div><div class="line">    <span class="comment">// construct undirected, loopfree graph G </span></div><div class="line"></div><div class="line">    leda::edge_array&lt;int&gt; len(G, 1);</div><div class="line"></div><div class="line">    <span class="comment">// fill up non-negative edge lengths </span></div><div class="line"></div><div class="line">    <a class="code" href="classmcb_1_1edge__num.html">mcb::edge_num</a> enumb( G );</div><div class="line">    leda::array&lt; mcb::spvecgf2 &gt; <a class="code" href="namespacemcb.html">mcb</a>;</div><div class="line">    <span class="keywordtype">int</span> weight = <a class="code" href="group__exactmcb.html#ga5330118659b9aca7c06ab2cdea4b9040">mcb::UMCB</a>( G, len, mcb, enumb ); </div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> i,j;</div><div class="line">    leda::edge e;</div><div class="line">    <span class="keywordflow">for</span>( i = 0; i &lt; enumb.dim_cycle_space(); ++i ) {</div><div class="line">            forall( j, mcb[i] ) { <span class="comment">// traverse edges of i-th cycle</span></div><div class="line">                    e = enumb( j );</div><div class="line"></div><div class="line">                    <span class="comment">// do something with edge e </span></div><div class="line">            }</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="ex_dir"></a>
Directed MCB</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mcb_8h.html">LEP/mcb/mcb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">     leda::graph G;</div><div class="line"></div><div class="line">     <span class="comment">// construct simple, loopfree, directed graph G </span></div><div class="line"></div><div class="line">     leda::edge_array&lt;int&gt; len(G, 1);</div><div class="line"></div><div class="line">     <span class="comment">// fill up positive edge lengths </span></div><div class="line"></div><div class="line">     leda::array&lt; mcb::spvecfp &gt; mcb;</div><div class="line">     <span class="keywordtype">int</span> weight = <a class="code" href="group__exactmcb.html#gaec572c237abd349ce4bc388fa532468f">mcb::DMCB</a>( G, len, mcb );</div><div class="line"></div><div class="line">     <span class="keywordtype">int</span> i;</div><div class="line">     leda::edge e;</div><div class="line">     <a class="code" href="namespacemcb.html#a6447f466cc418c58fd157504c198bb48">ptype</a> direction;</div><div class="line">     <span class="keywordflow">for</span>( i = 0; i &lt; enumb.dim_cycle_space(); ++i ) {</div><div class="line">             leda::list_item it = mcb[i].first();</div><div class="line">             <span class="keywordflow">while</span>( it != nil ) {</div><div class="line">                    e = enumb( mcb[i].index( it ) );</div><div class="line">                    direction = mcb[i].inf( it );</div><div class="line"></div><div class="line">                    <span class="comment">// do something with edge e</span></div><div class="line">                    <span class="comment">// direction is -1 or 1 based on traversing the cycle</span></div><div class="line">                    <span class="comment">// in some arbitrary direction</span></div><div class="line"></div><div class="line">                    it = mcb[i].succ( it );</div><div class="line">             }</div><div class="line">     }</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="ex_approx"></a>
Undirected 2k-1 Approximate MCB</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mcb_8h.html">LEP/mcb/mcb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    leda::graph G;</div><div class="line">    <span class="comment">// construct loopfree graph G </span></div><div class="line"></div><div class="line">    leda::edge_array&lt;int&gt; len(G, 1);</div><div class="line">    <span class="comment">// fill up non-negative edge lengths </span></div><div class="line"></div><div class="line">    <span class="comment">// setup constant for approximation factor 2k-1</span></div><div class="line">    <span class="keywordtype">int</span> k = 2; </div><div class="line"></div><div class="line">    <a class="code" href="classmcb_1_1edge__num.html">mcb::edge_num</a> enumb( G );</div><div class="line">    leda::array&lt; mcb::spvecgf2 &gt; mcb;</div><div class="line">    <span class="keywordtype">int</span> weight = <a class="code" href="group__approxmcb.html#gacc406b0b31f809c317998974fe28d9db">mcb::UMCB_APPROX</a>( G, len, k, mcb, enumb ); </div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> i,j;</div><div class="line">    leda::edge e;</div><div class="line">    <span class="keywordflow">for</span>( i = 0; i &lt; enumb.dim_cycle_space(); ++i ) {</div><div class="line">            forall( j, mcb[i] ) { <span class="comment">// traverse edges of i-th cycle</span></div><div class="line">                    e = enumb( j );</div><div class="line"></div><div class="line">                    <span class="comment">// do something with edge e </span></div><div class="line">            }</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
